Ioc(Inversion Of Control, 제어의 역전) : 프로그램의 제어 흐름을 개발자가 직접 제어(or 각 객체 내에서 직접 코드로 제어)하는 것이 아니라 외부에서 제어하는 것
→ 예를 들어, AppConfig 클래스(=외부)가 [애플리케이션의 구성에 대한 제어(=프로그램의 제어 흐름)]를 하였다 

※ 프로그램의 제어 흐름이란?
・각각의 구현 객체 내에 new를 사용하여 협력 객체를 설정x
・오로지 각 구현 객체의 본연의 로직에만 집중
・AppConfig 클래스가 협력 객체 설정을 담당
 → 각각의 구현 객체는 인테페이스에 의존하지만 "어떤 구현 객체에 의존하고 어떤 구현 객체가 실행" 되는 지 【각 객체】는 모른다.
이와 같은 맥락에서 프로그램의 제어 흐름이란 "의존하는 구현 객체의 설정"을 의미.


프레임워크 vs 라이브러리
・프레임워크 : 개발자가 작성한 코드를 대신 제어하고, 대신 실행하는 것이면 그건 프레임워크(AppConfig)
・라이브러리 : 개발자가 작성한 코드를 개발자가 직접 제어하고 실행한다면 그건 라이브러리
→ 쉽게 예를 들면, A라는 구현 객체가 있을 때, 그 안에 실행 시키고 싶은 코드를 개발자가 직접 삽입을 하면 그 삽입된 코드는 라이브러리이다.
반면에 원하는 실행을 개발자가 직접 코드 삽입하지 않고 외부에서 실행을 할 때 그건 프레임워크


의존관계 종류
・정적인 의존 관계(클래스 다이어그램으로 관계 파악)
・동적인 의존 관계(객체 다이어그램으로 관계 파악)
→ DIP를 준수한 【각 객체 입장】에서는 런타임 이전에는 인터페이스만 알지 어떤 구현 객체에 의존하는 지 알 수가 없고, 런타임 시에 비로소 알 수가 있다. 
런타임 시에 정해지는 각 구현 객체 간의 의존 관계를 동적인 의존 관계라고 한다.

DI(의존 관계 주입)
→ 【런타임 시점】에서 외부(AppConfig와 같은 프레임워크)에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결되는 것
의존 관계 주입 시에는 아래의 2가지가 전제되어야 한다.
・ 다형성에 의한 역할과 구현의 분리
・ DIP/OCP 준수

DI를 사용하는 이유
→ 정적인 클래스 의존관계를 변경하지 않고(=클래스 다이어그램의 구조를 그대로 유지하고), 동적인 객체 인스턴스 의존관계를 【쉽게 변경】 가능
즉, 클라이언트 코드의 변경 없이(or 애플리케이션 코드의 변경 없이) 동적인 객체 인스턴스 의존관계를 쉽게 변경 가능(AppConfig와 같은 프레임워크만 변경해주면 됨)
이건 유지/보수 비용 최소화라는 말과 치환될 수 있다

컨테이너(IoC 컨테이너, DI 컨테이너)
→AppConfig 클래스와 같이 애플리케이션 코드가 아닌 외부 프레임워크에서 "객체 생성 및 의존 관계 주입"을 해주는 것



 